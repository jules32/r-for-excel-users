# Dplyr and Pivot Tables {#pivot}

## Summary (a few sentences)

First of two chapters on data wrangling, here focused on pivot tables. 

## Objectives (more detailed, bulletpoints?)

In R, we can use dplyr for pivot tables by using 2 main verbs in combination: `group_by` and `summarize`, and that's where we'll start. Then, we will learn 2 critical verbs that you will use all the time: `select` and `mutate`.

- intro to wrangling with dplyr 
- learn select
- learn group_by + summarize for pivot tables
- emphasize reproducible research


## Resources

## Introduction / our analytical plan

We are going to continue with our analysis with the fish-counts data. So far, our RMarkdown has the following in the "setup" chunk: <!---TODO update after ch 3 complete --->

```{r setup, eval=FALSE}
## attach libraries
library(tidyverse)

## read in data
fish_counts <- read_csv("fish_counts_curated.csv")
```

```{r, include = FALSE}
# Teaching version
fish_counts <- read_csv("curation/fish_counts_curated.csv")
```

And we have explored the data by looking at some summary statistics and making a simple plot. Now, we are going to learn how to wrangle data in R, using the `dplyr` package which is included in the `tidyverse`. In this session, we'll focus on the functions in `dplyr` that operate like pivot tables.

This is because what we want to do with our fish_counts data is XXXXX. 

## What are pivot tables?

- what they are
- what they allow you to do

Let's talk about how this looks like in R. 

## dplyr for pivot tables

In R, we can use dplyr for pivot tables by using 2 main verbs in combination: `group_by` and `summarize`. Here is what this looks like:

`group_by` and `summarize` are the main ingredients for pivot tables: 

- **`group_by()`**: TODO: words here, screenshot without computed column!

  `r htmltools::img(src='img/rstudio-cheatsheet-group_by.png', width=300)`

- **`summarize()`**: collapse many values down to a single summary 

  `r htmltools::img(src='img/rstudio-cheatsheet-summarise.png', width=300)`
  
### group_by() summarize()  
  
Say it with me: pivot tables are "group_by summarize". And just like pivot tables, you have flexibility with how you are going to summarize. For example, we can calculate an average, or a total.

Let's try this on our fish_counts data. Let's summarize this data by calculating the the total number of fish by type, which in our dataframe is called `common_name`. We'll use the pipe operator `%>%`

```{r, eval=FALSE}
fish_counts %>%
  group_by(common_name) %>%
  summarize(total_fish = sum(total_count)) # within summarize, we name a new column and calculate the sum.
```

Way more seniorita fish than any other kind! 

Notice how together, group_by and summarize collapse the amount of information we see. We lose the other columns that aren't involved here; we no longer have `year`, `common_name`, or `total_count`. 

Question: What if you *don't* group_by first? Let's try it and discuss what's going on.

```{r, eval=FALSE}
fish_counts %>%
  summarize(total_fish = sum(total_count))
```

So if we don't group_by first, we will get a single summary statistic for the whole dataset. Useful in some cases for sure. 

Awesome! And we can still `View(fish_counts)` and see that we haven't changed any of our original data. But maybe we do want to save this summary as a variable so we can refer to it or even include it in further analyses. So let's add a variable assignment to that first line:

```{r, eval=FALSE}
common_name_summary <- fish_counts %>%
  group_by(common_name) %>%
  summarize(total_fish = sum(total_count))
```
  
Now let's summarize by site. We will assign it to a variable called `site_summary`. How do we do that? 

```{r, eval=FALSE}
site_summary <- fish_counts %>%
  group_by(site) %>%
  summarize(total_fish = sum(total_count))
```
  
Great. It can be useful to summarize by both site and year, so that we can learn a little more about how things change over time across sites. And we are able to group_by more than one variable. Let's do this together, and assign this to a new variable called `site_year_summary`:

```{r, eval=FALSE}
site_year_summary <- fish_counts %>%
  group_by(site, year) %>%
  summarize(total_fish = sum(total_count))
```

OK, so this is awesome. We can see the total counts for each site by year, and have this saved here in a nice variable. 

We will revisit this in a moment, but now let's move on to our next dplyr verb. 

### mutate()

We use the `mutate()` function to add columns to a data frame. This is one of the most common things that I do in Excel: you need to name the new column, and then you can fill it with new values. From the help pages, we learn that unlike `summarize()`, `mutate()` preserves the number of rows of the input. Additionally, new variables overwrite existing variables of the same name.

Let's say we need to add a column that indicates that these observations were made by SCUBA diving. We use the `mutate()` function, first naming the column (`observation_type`) and setting the value ("SCUBA"). We'll have to put SCUBA in quotes:

```{r, eval=FALSE}
fish_counts %>%
  mutate(observer_name = "SCUBA")
```

When you just set one value like "SCUBA", mutate will repeat this value for you; it's the equivalent in Excel to when you grab the bottom right corner of a cell and drag down. 

Let's try a calculation. Let's calculate the total count for the whole data site as we did above. We add a new column named `total_fish`:

```{r, eval=FALSE}
fish_counts %>%
  mutate(total_fish = sum(total_count))
```

And notice that this was the same calculated value as when we did this with summarize, but here it is repeated for every row instead of being collapsed. 

So there are many things you could add to a new column; but I want to demonstrate how powerful mutate can be in combination with group by. So just like we were just doing `group_by() %>% summarize()`, we can do `group_by() %>% mutate()`. 

Let's add a new column named `siteyear_counts`, and we will calculated after grouping by site and year. Let's have a look at it first, and then we will assign it as a variable in a moment.

```{r, eval=FALSE}
fish_counts %>%
  group_by(site, year) %>%
  mutate(siteyear_counts = sum(total_count))
```

We now have an additional column in our dataframe called `siteyear_counts`. And again, if we recall from our `site_year_summary` above, it has calculated the same information. But instead of collapsing our dataframe, we retain all of the information from the other columns, and the `siteyear_counts` column will have values that are repeated. 

### Activity

Take 3 minutes to add a new column to the data frame; discuss with your neighbor for ideas! 

### mutate() vs summarize()

Why would you use mutate instead of summarize? Why would you ever want to have this `total_fish` column with values repeated? Why wouldn't you always do group_by summarize rather than group_by mutate? Let's explore this: 


```{r, eval=FALSE}
group_by() %>% summarize()
group_by() %>% mutate()
```

Now let's say we want to calculate the percentage of fish type at each site. This means we are going to do a calculation using both the raw and summary data. And we're going to do it in 2 ways. 

I actually like to do this kind of calculation in a 

```{r, eval=FALSE}
fish_counts %>%
  group_by(site, year) %>%
  mutate(total_fish = sum(total_count)) %>%
  mutate(perc_fish = total_count/total_fish*100)
```



- **`select()`**: pick variables by their names

  `r htmltools::img(src='img/rstudio-cheatsheet-select.png', width=300)`
    
- **`mutate()`**: create new variables with functions of existing variables 

  `r htmltools::img(src='img/rstudio-cheatsheet-mutate.png', width=300)`
    
  

All dplyr verbs can be used in conjunction with `group_by()` which changes the scope of each function from operating on the entire dataset to operating on it group-by-group. 

All dplyr verbs work similarly:

1. The first argument is a data frame.
2. The subsequent arguments describe what to do with the data frame. You can refer to columns in the data frame directly without using `$`.
3. The result is a new data frame.

Together these properties make it easy to chain together multiple simple steps to achieve a complex result.


## Deep thought






## Fun facts (quirky things) - making a note of these wherever possible for interest (little “Did you know?” sections)
## Interludes (deep thoughts/openscapes)
## Our Turn Your Turn 1
## Our Turn Your Turn 2
## Efficiency Tips


[
["vlookup.html", "Chapter 6 Dplyr and vlookups 6.1 Summary 6.2 Objectives 6.3 Resources 6.4 Lessons 6.5 Fun facts 6.6 Interludes (deep thoughts/openscapes) 6.7 Our Turn Your Turn 1 6.8 Our Turn Your Turn 2 6.9 Efficiency Tips", " Chapter 6 Dplyr and vlookups 6.1 Summary In Session 4, we learned how to do some basic wrangling and find summary information with functions in the dplyr package, which exists within the tidyverse. Those were: TODO: Check this list (to see what actually gets covered in Session 4) dplyr::select(): select which columns to retain or exclude dplyr::mutate(): add a new column, while keeping the existing ones dplyr::group_by(): let R know that groups exist within the dataset, by variable(s) dplyr::summarize(): calculate a value (that you specify) for each group, then report each group’s value in a table In Session 5, we’ll expand our data wrangling toolkit using: dplyr::filter() to conditionally subset our data by rows, and dplyr::join() functions to merge data frames together The combination of dplyr::filter() and dplyr::join() - to return rows satisfying a condition we specify, and merging data frames by like variables - is analogous to the useful VLOOKUP function in Excel. 6.2 Objectives Continue building R Markdown skills Return rows that satisfy variable conditions using dplyr::filter() Use dplyr::full_join(), dplyr::inner_join(), and beyond to merge data frames by matching variables, with different endpoints in mind Use dplyr::anti_join() to find things that do not exist in both data frames Understand the similarities between dplyr::filter() + join() and Excel’s VLOOKUP 6.3 Resources dplyr::filter() documentation from tidyverse.org dplyr::join() documentation from tidyverse.org Chapters 5 and 13 in R for Data Science by Garrett Grolemund and Hadley Wickham 6.4 Lessons Session 5 set-up: TODO Create a new .Rmd within the r-and-excel directory (project) you created in Session 1 Add some descriptive text Add new code chunks to: Attach packages Read in the necessary data In this session we’ll use the fish_counts_curated.csv and invert_counts_curated.xlsx files, and the first worksheet from kelp_counts_curated.xlsx. # Attach packages: library(tidyverse) library(readxl) # Read in data: invert_counts &lt;- read_excel(&quot;invert_counts_curated.xlsx&quot;) fish_counts &lt;- read_csv(&quot;fish_counts_curated.csv&quot;) kelp_counts_abur &lt;- read_excel(&quot;kelp_counts_curated.xlsx&quot;) Remember to always explore the data you’ve read in using functions like View(), names(), summary(), head() and tail() to ensure that the data you think you read in is actually the data you read in. Now, let’s use dplyr::filter() to decide which observations (rows) we’ll keep or exclude in new subsets, similar to using Excel’s VLOOKUP function. 6.4.1 dplyr::filter() to conditionally subset by rows Use dplyr::filter() to let R know which rows you want to keep or exclude, based on what they contain. Some examples in words: “I only want to keep rows where the temperature is greater than 90°F.” “I want to keep all observations except those where the tree type is listed as unknown.” “I want to make a new subset with only data for mountain lions (the species variable) in California (the state variable).” TODO: {Add filter image here} When we use dplyr::filter(), we need to let R know a couple of things: What data frame we’re filtering from What condition(s) we want observations to match and/or not match in order to keep them in the new subset Follow along with the examples below to learn some common ways to use dplyr::filter(). 6.4.1.1 Filter rows by matching a single character string Let’s say we want to keep all observations from the fish_counts data frame where the common name is “garibaldi.” Here, we need to tell R to only keep rows from the fish_counts data frame when the common name (common_name variable) exactly matches garibaldi. Use == to ask R to look for matching strings: fish_gari &lt;- dplyr::filter(fish_counts, common_name == &quot;garibaldi&quot;) Check out the fish_gari object to ensure that only garibaldi observations remain. You could also do this using the pipe operator %&gt;% (though for a single function, it doesn’t save much effort or typing): fish_gari &lt;- fish_counts %&gt;% dplyr::filter(common_name == &quot;garibaldi&quot;) 6.4.1.2 Filter rows based on numeric conditions Use expected operators (&gt;, &lt;, &gt;=, &lt;=, =) to set conditions for a numeric variable when filtering. For this example, we only want to retain observations when the tot_count column value is &gt;= 50: fish_over50 &lt;- dplyr::filter(fish_counts, tot_count &gt;= 50) Or, using the pipe: fish_over50 &lt;- fish_counts %&gt;% dplyr::filter(tot_count &gt;= 50) TODO: show example of between and exact = 6.4.1.3 Filter to return rows that match this OR that OR that What if we want to return a subset of the fish_counts df that contains garibaldi, blacksmith OR black surfperch? There are several ways to write an “OR” statement for filtering, which will keep any observations that match Condition A or Condition B or Condition C. In this example, we will create a subset from fish_counts that only contains rows where the common_name is garibaldi or blacksmith or black surfperch. Use %in% to ask R to look for any matches within a combined vector of strings: fish_3sp &lt;- fish_counts %&gt;% dplyr::filter(common_name %in% c(&quot;garibaldi&quot;, &quot;blacksmith&quot;, &quot;black surfperch&quot;)) Alternatively, you can indicate OR using the vertical line operator | to do the same thing (but you can see that it’s more repetitive when looking for matches within the same variable): fish_3sp &lt;- fish_counts %&gt;% dplyr::filter(common_name == &quot;garibaldi&quot; | common_name == &quot;blacksmith&quot; | common_name == &quot;black surfperch&quot;) 6.4.1.4 Filter to return rows that match conditions for multiple variables In the previous examples, we set filter conditions based on a single variable (e.g. common_name). What if we want to return observations that satisfy conditions for multiple variables? For example: We want to create a subset that only returns rows from ‘invert_counts’ where the site is “abur” or “mohk” and the common_name is “purple urchin.” In dplyr::filter(), add a comma (or ampersand, &amp;) between arguments for multiple AND conditions: urchin_abur_mohk &lt;- invert_counts %&gt;% dplyr::filter(site %in% c(&quot;abur&quot;,&quot;mohk&quot;), common_name == &quot;purple urchin&quot;) head(urchin_abur_mohk) ## # A tibble: 2 x 6 ## month site common_name `2016` `2017` `2018` ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 7 abur purple urchin 48 48 48 ## 2 7 mohk purple urchin 620 505 323 Like most things in R, there are other ways to do the same thing. For example, you could do the same thing using &amp; (instead of a comma) between “and” conditions: # Use the ampersand (&amp;) to add another condition &quot;and this must be true&quot;: urchin_abur_mohk &lt;- invert_counts %&gt;% dplyr::filter(site %in% c(&quot;abur&quot;,&quot;mohk&quot;) &amp; common_name == &quot;purple urchin&quot;) Or you could just do two filter steps in sequence: # Written as multiple filter steps: urchin_abur_mohk &lt;- invert_counts %&gt;% dplyr::filter(site %in% c(&quot;abur&quot;, &quot;mohk&quot;)) %&gt;% dplyr::filter(common_name == &quot;purple urchin&quot;) 6.4.1.5 Filter to return rows that do not match conditions Sometimes we might want to exclude observations. Here, let’s say we want to make a subset that contains all rows from fish_counts except those recorded at the Mohawk Reef site (“mohk” in the site variable). We use != to return observations that do not match a condition. Like this: fish_no_mohk &lt;- fish_counts %&gt;% dplyr::filter(site != &quot;mohk&quot;) This similarly works to exclude observations by a value. For example, if we want to return all observations except those where the total fish count is 1, we use: fish_more_one &lt;- fish_counts %&gt;% dplyr::filter(tot_count != 1) What if we want to exclude observations for multiple conditions? For example, here we want to return all rows where the fish species is not garibaldi or rock wrasse. We can use filter(!variable %in% c(&quot;apple&quot;, &quot;orange&quot;)) to return rows where the variable does not match “apple” or “orange”. For our fish example, that looks like this: fish_subset &lt;- fish_counts %&gt;% dplyr::filter(!common_name %in% c(&quot;garibaldi&quot;, &quot;rock wrasse&quot;)) Which then only returns observations for the other fish species in the dataset. head(fish_subset) ## # A tibble: 6 x 4 ## year site common_name tot_count ## &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2016 abur black surfperch 2 ## 2 2016 abur blacksmith 1 ## 3 2016 abur senorita 58 ## 4 2016 aque black surfperch 1 ## 5 2016 aque blacksmith 1 ## 6 2016 aque senorita 57 6.4.1.6 Example: Some combo w/previous functions used We can also use dplyr::filter() in combination with the functions we learned for wrangling yesterday. If we have multiple sequential steps to perform, we can string them together using the pipe operator (%&gt;%). 6.4.2 Merging data frames with dplyr::*_join() Excel’s VLOOKUP can also be used to merge data from separate tables or worksheets. Here, we’ll use the dplyr::*_join() functions to merge separate data frames in R. There are a number of ways to merge data frames in R. We’ll use full_join() and inner_join() in this session. From R Documentation (?join): dplyr::full_join(): “returns all rows and all columns from both x and y. Where there are not matching values, returns NA for the one missing.” Basically, nothing gets thrown out, even if a match doesn’t exist - making full_join() the safest option for merging data frames. dplyr::inner_join(): “returns all rows from x where there are matching values in y, and all columns from x and y. If there are multiple matches between x and y, all combination of the matches are returned.” This will drop observations that don’t have a match between the merged data frames, which makes it a riskier merging option if you’re not sure what you’re trying to do. When in doubt, full_join(). 6.4.2.1 dplyr::full_join() to merge data frames, keeping everything When we join data frames in R, we need to tell R a couple of things (and it does the hard joining work for us): Which data frames we want to merge together Which variables* to merge by Note: If there are exactly matching column names in the data frames you’re merging, the *_join() functions will assume that you want to join by those columns. If there are no matching column names, you can specify which columns to join by manually. We’ll do both here. # Join the fish_counts and kelp_counts_abur together: abur_kelp_join &lt;- fish_counts %&gt;% full_join(kelp_counts_abur) # Uh oh. An error message. When we try to do that join, we get an error message: Error: Can't join on 'year' x 'year' because of incompatible types (character / numeric) What’s going on here? First, there’s something fishy (ha) going on with the class of the year variable in kelp_counts_abur. Use the class() function to see how R understands that variable (remember, we use $ to return a specific column from a data frame). class(kelp_counts_abur$year) ## [1] &quot;character&quot; So the variable is currently stored as a character. Why? If we go back to the kelp_counts_curated.xlsx file, we’ll see that the numbers in both the year and month column have been stored as text. There are several hints Excel gives us: Cells are left aligned, when values stored as numbers are right aligned The green triangles in the corner indicate some formatting The warning sign shows up when you click on one of the values with text formatting, and lets you know that the cell has been stored as text. We are given the option to reformat as numeric in Excel, but we’ll do it here in R so we have a reproducible record of the change to the variable class. There are a number of ways to do this in R. We’ll use dplyr::mutate() to overwrite the existing year column while coercing it to class numeric using the as.numeric() function. # Coerce the class of &#39;year&#39; to numeric kelp_counts_abur &lt;- kelp_counts_abur %&gt;% mutate(year = as.numeric(year)) Now if we check the class of the year variable in kelp_counts_abur, we’ll see that it has been coerced to ‘numeric’: class(kelp_counts_abur$year) ## [1] &quot;numeric&quot; Question: Isn’t it bad practice to overwrite variables, instead of just making a new one? Great question, and usually the answer is yes. Here, we feel fine with “overwriting” the year column because we’re not changing anything about what’s contained within the column, we’re only changing how R understands it. Always use caution if overwriting variables, and if in doubt, add one instead! OK, so now the class of year in the data frames we’re joining is the same. Let’s try that full_join() again: abur_kelp_join &lt;- fish_counts %&gt;% full_join(kelp_counts_abur) ## Joining, by = c(&quot;year&quot;, &quot;site&quot;) First, notice that R tells us which sites it is joining by - in this case, year and site since those were the two matching variables in both data frames. Now look at the merged data frame with View(abur_kelp_join). 6.4.2.2 dplyr::inner_join() to merge data frames, only keeping observations with a match in both 6.5 Fun facts How is this similar to VLOOKUP in Excel? How does it differ? From Microsoft Office Support, “use VLOOKUP when you need to find things in a table or a range by row.” So, both filter() and VLOOKUP look through your data frame (or spreadsheet, in Excel) to look for observations that match your conditions. But they also differ in important ways: By default VLOOKUP looks for and returns an observation for approximate matches (and you have to change the final argument to FALSE to look for an exact match). In contrast, by default dplyr::filter() will look for exact conditional matches. VLOOKUP will look for and return information from the first observation that matches (or approximately matches) a condition. dplyr::filter() will return all observations (rows) that exactly match a condition. 6.6 Interludes (deep thoughts/openscapes) Idea: not overusing the pipe in really long sequences. What are other options? Why is that a concern? What are some ways to always know that what’s happening in a sequence is what you EXPECT is happening in a sequence? tidylog, check intermediate data frames, sometimes write intermediate data frames, etc. 6.7 Our Turn Your Turn 1 6.8 Our Turn Your Turn 2 6.9 Efficiency Tips "]
]

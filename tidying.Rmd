# Tidying <- possibly "Reshaping & tidying"? 

## Summary

In previous sessions, we learned to read in data, do some wrangling, and create a graph and table. Here, we'll continue by *reshaping* data frames (converting from long-to-wide, or wide-to-long format), *separating* and *uniting* variable (column) contents, converting between *explicit* and *implicit* missing (`NA`) values, and cleaning up our column names with the `janitor` package. 

## Objectives

- Convert column names with `janitor::clean_names()`
- Reshape data frames with `tidyr::pivot_longer()` and `tidyr::pivot_wider()`
- Combine or separate information from columns with `tidyr::separate()` and `tidyr::unite()`
- Make implicit missings *explicit* with `tidyr::complete()`
- Make explicit missings *implicit* with `tidyr::drop_na()`
- Use our new skills as part of a bigger wrangling sequence
- Make a customized table 

## Resources

-- [Ch. 12 *Tidy Data*, in R for Data Science](https://r4ds.had.co.nz/tidy-data.html) by Grolemund & Wickham
- [`tidyr` documentation from tidyverse.org](https://tidyr.tidyverse.org/)
- [`janitor` repo / information](https://github.com/sfirke/janitor) from Sam Firke

## Lesson

### Lesson Prep

#### Create a new R Markdown and attach packages

Within your day 2 R Project, create a new .Rmd. Attach the `tidyverse`, `janitor` and `readxl` packages with `library(package_name)`. Knit and save your new .Rmd within the project folder. 

```{r, include = FALSE}
# Attach packages
library(tidyverse)
library(janitor)
library(readxl)
```

```{r, eval = FALSE}
# Attach packages
library(tidyverse)
library(janitor)
library(readxl)
```

#### Read in data

Use `readxl::read_excel()` to import the "invert_counts_curated.xlsx" data:
```{r, include = FALSE}
inverts_df <- readxl::read_excel(here::here("curation", "invert_counts_curated.xlsx"))
```

```{r, eval = FALSE}
inverts_df <- readxl::read_excel("invert_counts_curated.xlsx")
```

Be sure to explore the imported data a bit: 

- `View()`
- `names()`
- `summary()`

### Reshaping with `tidyr::pivot_longer()` and `tidyr::pivot_wider()`

In *tidy format*, each variable is contained within a single column. If we look at *inverts_df*, we can see that the *year* variable is actually split over 3 columns, so we'd say this is currently in **wide format**. 

There may be times when you want to have data in wide format, but often with code it is more efficient to convert to **long format** by gathering together observations for a variable that is currently split into multiple columns. 

Schematically, converting from wide to long format looks like this: 

![](img/tidyr_pivot_longer.png)

To gather wide columns together (in our case, the 'year' columns), use `tidyr::pivot_longer()` as follows: 

TODO: Add pivot_longer() schematic

We'll use `tidyr::pivot_longer()` to gather data from all years in *inverts_df* into two columns: one called *year*, which contains the year (as a number), and another called *sp_count* that contains the number of each species observed. The new data frame will be stored as *inverts_long*:

```{r}

inverts_long <- tidyr::pivot_longer(data = inverts_df, 
                                    cols = '2016':'2018',
                                    names_to = "year",
                                    values_to = "sp_count")

```

The outcome is the new long-format *inverts_long* data frame:
```{r}
inverts_long
```

Hooray, long format! 

One thing that isn't obvious at first (but would become obvious if you continued working with this data) is that since those year numbers were initially column names (characters), when they are stacked into the *year* column, their class wasn't auto-updated to numeric. 

Explore the class of *year* in *inverts_long*:

```{r}
class(inverts_long$year)
```

We'll use `dplyr::mutate()` in a different way here: to create a new column (that's how we've used `mutate()` previously) that has the same name of an existing column, in order to update and overwrite the existing column. 

In this case, we'll `mutate()` to add a column called *year*, which contains an `as.numeric()` version of the existing *year* variable: 

```{r}

# Coerce "year" class to numeric: 

inverts_long <- inverts_long %>% 
  mutate(year = as.numeric(year))

```

Checking the class again, we see that *year* has been updated to a numeric variable: 

```{r}
class(inverts_long$year)
```

